error[E0106]: missing lifetime specifiers
 --> src/lib/open_safer.rs:6:31
  |
6 | pub type __builtin_va_list = [__va_list_tag; 1];
  |                               ^^^^^^^^^^^^^ expected 2 lifetime parameters
  |
help: consider introducing a named lifetime parameter
  |
6 | pub type __builtin_va_list<'a> = [__va_list_tag<'a, 'a>; 1];
  |                           ++++                 ++++++++


error[E0106]: missing lifetime specifiers
  --> src/lib/printf.rs:13:31
   |
13 | pub type __builtin_va_list = [__va_list_tag; 1];
   |                               ^^^^^^^^^^^^^ expected 2 lifetime parameters
   |
help: consider introducing a named lifetime parameter
   |
13 | pub type __builtin_va_list<'a> = [__va_list_tag<'a, 'a>; 1];
   |                           ++++                 ++++++++


error[E0106]: missing lifetime specifier
  --> src/lib/sig_handler.rs:85:20
   |
85 |     pub si_sigval: sigval,
   |                    ^^^^^^ expected named lifetime parameter
   |
help: consider using the `'h60` lifetime
   |
85 |     pub si_sigval: sigval<'h60>,
   |                          ++++++


error[E0308]: mismatched types
   --> src/trees.rs:156:23
    |
156 |             dyn_tree: dyn_ltree.as_ptr() as *mut _,
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[Cell<ct_data>]`, found *-ptr
    |
    = note: expected reference `&[Cell<ct_data>]`
             found raw pointer `*mut _`


error[E0308]: mismatched types
   --> src/trees.rs:158:25
    |
158 |             extra_bits: extra_lbits.as_ptr() as *mut _,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[i32]`, found *-ptr
    |
    = note: expected reference `&[i32]`
             found raw pointer `*mut _`


error[E0308]: mismatched types
   --> src/trees.rs:171:26
    |
171 |             static_tree: static_dtree.as_ptr() as *mut _,
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[ct_data]`, found *-ptr
    |
    = note: expected reference `&[ct_data]`
             found raw pointer `*mut _`


error[E0308]: mismatched types
   --> src/trees.rs:184:23
    |
184 |             dyn_tree: bl_tree.as_ptr() as *mut _,
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[Cell<ct_data>]`, found *-ptr
    |
    = note: expected reference `&[Cell<ct_data>]`
             found raw pointer `*mut _`


error[E0308]: mismatched types
   --> src/trees.rs:186:25
    |
186 |             extra_bits: extra_blbits.as_ptr() as *mut _,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[i32]`, found *-ptr
    |
    = note: expected reference `&[i32]`
             found raw pointer `*mut _`


error[E0308]: mismatched types
  --> src/lib/dirname_lgpl.rs:61:56
   |
61 |       let mut dir: &[core::cell::Cell<(libc::c_char)>] = std::cell::Cell::from_mut((malloc(
   |  __________________-----------------------------------___^
   | |                  |
   | |                  expected due to this
62 | |         length
63 | |             .wrapping_add(append_dot as libc::c_ulong)
64 | |             .wrapping_add(1 as libc::c_int as libc::c_ulong),
65 | |     )));
   | |_______^ expected slice, found struct `Cell`
   |
   = note: expected reference `&[Cell<i8>]`
              found reference `&Cell<_>`


error[E0308]: mismatched types
  --> src/lib/dirname_lgpl.rs:67:16
   |
55 | pub unsafe extern "C" fn mdir_name<'h0,'h1>(mut file: &'h0 [(libc::c_char)]) -> &'h1 core::cell::Cell<(libc::c_char)> {
   |                                                                                 ------------------------------------- expected `&'h1 Cell<i8>` because of return type
...
67 |         return 0 as *mut libc::c_char;
   |                ^^^^^^^^^^^^^^^^^^^^^^ expected `&Cell<i8>`, found *-ptr
   |
   = note: expected reference `&'h1 Cell<i8>`
            found raw pointer `*mut i8`


error[E0308]: mismatched types
  --> src/lib/pipe_safer.rs:10:13
   |
10 |     if pipe(fd) == 0 as libc::c_int {
   |        ---- ^^ expected `i32`, found slice `[i32]`
   |        |
   |        arguments to this function are incorrect
   |
   = note:    expected raw pointer `*mut i32`
           found mutable reference `&'h0 mut [i32]`
note: function defined here
  --> src/lib/pipe_safer.rs:5:8
   |
5  |     fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
   |        ^^^^


error[E0599]: no method named `set` found for raw pointer `*mut i32` in the current scope
   --> src/lib/pipe_safer.rs:18:38
    |
18  |                 (__errno_location()).set((e));
    |                                      ^^^
    |
   ::: /home/hzy/.rustup/toolchains/nightly-2022-08-08-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/pin.rs:659:12
    |
659 |     pub fn set(&mut self, value: P::Target)
    |            --- the method is available for `Pin<&mut *mut i32>` here
    |
    = note: try using `<*const T>::as_ref()` to get a reference to the type behind the pointer: https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref
    = note: using `<*const T>::as_ref()` on a pointer which is unaligned or points to invalid or uninitialized memory is undefined behavior
help: consider wrapping the receiver expression with the appropriate type
    |
18  |                 Pin::new(&mut (__errno_location())).set((e));
    |                 +++++++++++++                     +
help: there is an associated function with a similar name
    |
18  |                 (__errno_location()).offset((e));
    |                                      ~~~~~~


error[E0308]: mismatched types
   --> src/lib/printf_args.rs:139:36
    |
139 |                 (*ap).a.a_string = args.arg::<*const libc::c_char>();
    |                 ----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0308]: mismatched types
   --> src/lib/printf_args.rs:141:40
    |
141 |                     (*ap).a.a_string = b"(NULL)\0" as *const u8 as *const libc::c_char;
    |                     ----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |                     |
    |                     expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0599]: no method named `is_null` found for reference `&i32` in the current scope
   --> src/lib/printf_args.rs:146:44
    |
146 |                 if ((*ap).a.a_wide_string).is_null() {
    |                                            ^^^^^^^ method not found in `&i32`


error[E0308]: mismatched types
   --> src/lib/printf_args.rs:160:37
    |
160 |                 (*ap).a.a_pointer = args.arg::<*mut libc::c_void>();
    |                 -----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&c_void`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&c_void`
             found raw pointer `*mut c_void`


error[E0308]: mismatched types
   --> src/lib/printf_args.rs:166:49
    |
166 |                 (*ap).a.a_count_short_pointer = args.arg::<*mut libc::c_short>();
    |                 -----------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i16`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&i16`
             found raw pointer `*mut i16`


error[E0308]: mismatched types
   --> src/lib/printf_args.rs:172:51
    |
172 |                 (*ap).a.a_count_longint_pointer = args.arg::<*mut libc::c_long>();
    |                 -------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i64`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&i64`
             found raw pointer `*mut i64`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:130:16
    |
130 |     (*a).arg = ((*a).direct_alloc_arg).as_mut_ptr();
    |     --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`, found *-ptr
    |     |
    |     expected due to the type of this binding
    |
    = note: expected reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
             found raw pointer `*mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:145:27
    |
145 |         (*dp).dir_start = cp.offset(-(1 as libc::c_int as isize));
    |         ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |         |
    |         expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:148:27
    |
148 |         (*dp).width_end = 0 as *const libc::c_char;
    |         ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |         |
    |         expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:151:31
    |
151 |         (*dp).precision_end = 0 as *const libc::c_char;
    |         -------------------   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |         |
    |         expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:231:31
    |
231 |             (*dp).width_end = cp;
    |             ---------------   ^^ expected `&i8`, found *-ptr
    |             |
    |             expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0369]: binary operation `==` cannot be applied to type `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:328:29
    |
328 |                 if (*a).arg == ((*a).direct_alloc_arg).as_mut_ptr() {
    |                    -------- ^^ ------------------------------------ *mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>
    |                    |
    |                    &printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:343:30
    |
343 |                 (*((*a).arg).offset(fresh2 as isize)).type_0 = TYPE_NONE;
    |                              ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:348:30
    |
348 |                 (*((*a).arg).offset(n_1 as isize)).type_0 = TYPE_INT;
    |                              ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:357:33
    |
357 |             (*dp).width_start = cp;
    |             -----------------   ^^ expected `&i8`, found *-ptr
    |             |
    |             expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0599]: no method named `offset_from` found for reference `&i8` in the current scope
   --> src/lib/printf_parse.rs:363:46
    |
363 |             width_length = ((*dp).width_end).offset_from((*dp).width_start)
    |                                              ^^^^^^^^^^^ method not found in `&i8`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:376:39
    |
376 |                 (*dp).precision_end = cp;
    |                 -------------------   ^^ expected `&i8`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0369]: binary operation `==` cannot be applied to type `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:473:33
    |
473 |                     if (*a).arg == ((*a).direct_alloc_arg).as_mut_ptr() {
    |                        -------- ^^ ------------------------------------ *mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>
    |                        |
    |                        &printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:488:34
    |
488 |                     (*((*a).arg).offset(fresh4 as isize)).type_0 = TYPE_NONE;
    |                                  ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:493:34
    |
493 |                     (*((*a).arg).offset(n_3 as isize)).type_0 = TYPE_INT;
    |                                  ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:502:41
    |
502 |                 (*dp).precision_start = cp.offset(-(1 as libc::c_int as isize));
    |                 ---------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
    |                 |
    |                 expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0599]: no method named `offset_from` found for reference `&i8` in the current scope
   --> src/lib/printf_parse.rs:511:22
    |
511 |                     .offset_from((*dp).precision_start) as libc::c_long as size_t;
    |                      ^^^^^^^^^^^ method not found in `&i8`


error[E0369]: binary operation `==` cannot be applied to type `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:710:29
    |
710 |                 if (*a).arg == ((*a).direct_alloc_arg).as_mut_ptr() {
    |                    -------- ^^ ------------------------------------ *mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>
    |                    |
    |                    &printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:725:30
    |
725 |                 (*((*a).arg).offset(fresh7 as isize)).type_0 = TYPE_NONE;
    |                              ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0599]: no method named `offset` found for reference `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:730:30
    |
730 |                 (*((*a).arg).offset(n_4 as isize)).type_0 = type_0;
    |                              ^^^^^^ method not found in `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`


error[E0308]: mismatched types
   --> src/lib/printf_parse.rs:739:25
    |
739 |         (*dp).dir_end = cp;
    |         -------------   ^^ expected `&i8`, found *-ptr
    |         |
    |         expected due to the type of this binding
    |
    = note: expected reference `&i8`
             found raw pointer `*const i8`


error[E0369]: binary operation `==` cannot be applied to type `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:777:25
    |
777 |             if (*d).dir == ((*d).direct_alloc_dir).as_mut_ptr() {
    |                -------- ^^ ------------------------------------ *mut printf_parse::char_directive<'_, '_, '_, '_, '_, '_>
    |                |
    |                &printf_parse::char_directive<'_, '_, '_, '_, '_, '_>


error[E0369]: binary operation `!=` cannot be applied to type `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:792:25
    |
792 |             if (*a).arg != ((*a).direct_alloc_arg).as_mut_ptr() {
    |                -------- ^^ ------------------------------------ *mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>
    |                |
    |                &printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>


error[E0369]: binary operation `!=` cannot be applied to type `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>`
   --> src/lib/printf_parse.rs:802:25
    |
802 |             if (*a).arg != ((*a).direct_alloc_arg).as_mut_ptr() {
    |                -------- ^^ ------------------------------------ *mut printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>
    |                |
    |                &printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>


error[E0599]: no method named `offset` found for reference `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>` in the current scope
   --> src/lib/printf_parse.rs:812:47
    |
812 |             let ref mut fresh8 = (*((*d).dir).offset((*d).count as isize)).dir_start;
    |                                               ^^^^^^ method not found in `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>`


error[E0606]: casting `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` as `*const c_void` is invalid
   --> src/lib/printf_parse.rs:331:25
    |
331 |                         (*a).arg as *const libc::c_void,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0606]: casting `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` as `*const c_void` is invalid
   --> src/lib/printf_parse.rs:476:29
    |
476 | ...                   (*a).arg as *const libc::c_void,
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0606]: casting `&printf_parse::argument<'_, '_, '_, '_, '_, '_, '_, '_>` as `*const c_void` is invalid
   --> src/lib/printf_parse.rs:713:25
    |
713 |                         (*a).arg as *const libc::c_void,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0606]: casting `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>` as `*const c_void` is invalid
   --> src/lib/printf_parse.rs:780:21
    |
780 |                     (*d).dir as *const libc::c_void,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0606]: casting `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>` as `*mut c_void` is invalid
   --> src/lib/printf_parse.rs:796:22
    |
796 |                 free((*d).dir as *mut libc::c_void);
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0606]: casting `&printf_parse::char_directive<'_, '_, '_, '_, '_, '_>` as `*mut c_void` is invalid
   --> src/lib/printf_parse.rs:806:22
    |
806 |                 free((*d).dir as *mut libc::c_void);
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0308]: mismatched types
  --> src/lib/save_cwd.rs:30:23
   |
30 |         (*cwd).name = getcwd(0 as *mut libc::c_char, 0 as libc::c_int as size_t);
   |         -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&i8`, found *-ptr
   |         |
   |         expected due to the type of this binding
   |
   = note: expected reference `&i8`
            found raw pointer `*mut i8`


error[E0308]: mismatched types
  --> src/lib/save_cwd.rs:44:27
   |
44 |         return chdir_long((*cwd).name)
   |                ---------- ^^^^^^^^^^^ types differ in mutability
   |                |
   |                arguments to this function are incorrect
   |
   = note: expected raw pointer `*mut i8`
                found reference `&i8`
note: function defined here
  --> src/lib/save_cwd.rs:7:8
   |
7  |     fn chdir_long(dir: *mut libc::c_char) -> libc::c_int;
   |        ^^^^^^^^^^


error[E0308]: arguments to this function are incorrect
   --> src/lib/savedir.rs:114:12
    |
114 |     return strcmp((*dea).name, (*deb).name);
    |            ^^^^^^ -----------  ----------- expected `i8`, found slice `[i8]`
    |                   |
    |                   expected `i8`, found slice `[i8]`
    |
    = note: expected raw pointer `*const i8`
                 found reference `&[i8]`
    = note: expected raw pointer `*const i8`
                 found reference `&[i8]`
note: function defined here
   --> src/lib/savedir.rs:20:8
    |
20  |     fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    |        ^^^^^^


error[E0308]: mismatched types
   --> src/lib/savedir.rs:232:36
    |
232 |                     ((stpcpy(dest, (*entries.offset(i as isize)).name)).offset_from(dest)
    |                       ------       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i8`, found slice `[i8]`
    |                       |
    |                       arguments to this function are incorrect
    |
    = note: expected raw pointer `*const i8`
                 found reference `&[i8]`
note: function defined here
   --> src/lib/savedir.rs:22:8
    |
22  |     fn stpcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    |        ^^^^^^


error[E0599]: no method named `is_null` found for reference `&'h0 c_void` in the current scope
  --> src/lib/xmalloc.rs:34:10
   |
34 |     if p.is_null() {
   |          ^^^^^^^ method not found in `&'h0 c_void`


error[E0599]: no method named `is_null` found for struct `Cell` in the current scope
  --> src/lib/xmalloc.rs:80:16
   |
80 |     if &(p)[0].is_null() && n != 0 as libc::c_int as libc::c_ulong {
   |                ^^^^^^^ method not found in `Cell<c_void>`


error[E0308]: mismatched types
  --> src/lib/xmalloc.rs:91:14
   |
91 |         free(p);
   |         ---- ^ types differ in mutability
   |         |
   |         arguments to this function are incorrect
   |
   = note: expected raw pointer `*mut c_void`
                found reference `&'h0 c_void`
note: function defined here
  --> src/lib/xmalloc.rs:7:8
   |
7  |     fn free(__ptr: *mut libc::c_void);
   |        ^^^^


error[E0308]: mismatched types
  --> src/lib/xmalloc.rs:94:17
   |
94 |     p = realloc(p, n);
   |         ------- ^ types differ in mutability
   |         |
   |         arguments to this function are incorrect
   |
   = note: expected raw pointer `*mut c_void`
                found reference `&'h0 c_void`
note: function defined here
  --> src/lib/xmalloc.rs:6:8
   |
6  |     fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
   |        ^^^^^^^


error[E0599]: no method named `is_null` found for reference `&'h0 c_void` in the current scope
  --> src/lib/xmalloc.rs:95:10
   |
95 |     if p.is_null() && n != 0 {
   |          ^^^^^^^ method not found in `&'h0 c_void`


error[E0308]: mismatched types
   --> src/lib/xmalloc.rs:109:12
    |
108 | pub unsafe extern "C" fn xzalloc<'h0>(mut s: size_t) -> &'h0 (libc::c_void) {
    |                                                         ------------------- expected `&'h0 c_void` because of return type
109 |     return memset(xmalloc(s), 0 as libc::c_int, s);
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&c_void`, found *-ptr
    |
    = note: expected reference `&'h0 c_void`
             found raw pointer `*mut c_void`


error[E0308]: mismatched types
   --> src/lib/xmalloc.rs:124:17
    |
113 |     let mut p: &(libc::c_void) = 0 as *mut libc::c_void;
    |                --------------- expected due to this type
...
124 |             p = calloc(n, s);
    |                 ^^^^^^^^^^^^ expected `&c_void`, found *-ptr
    |
    = note: expected reference `&c_void`
             found raw pointer `*mut c_void`


error[E0277]: the trait bound `Cell<c_void>: std::marker::Copy` is not satisfied
    --> src/lib/xmalloc.rs:142:15
     |
142  |     dest[..n].copy_from_slice(&src[..n]);
     |               ^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Cell<c_void>`
     |
note: required by a bound in `core::slice::<impl [T]>::copy_from_slice`
    --> /home/hzy/.rustup/toolchains/nightly-2022-08-08-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3216:12
     |
3216 |         T: Copy,
     |            ^^^^ required by this bound in `core::slice::<impl [T]>::copy_from_slice`


error[E0308]: mismatched types
   --> src/lib/xmalloc.rs:143:5
    |
143 |     dest
    |     ^^^^ expected enum `c_void`, found slice
    |
    = note: expected reference `&'h1 c_void`
               found reference `&[Cell<c_void>]`


error[E0308]: mismatched types
   --> src/lib/xmalloc.rs:149:9
    |
148 |     return xmemdup(
    |            ------- arguments to this function are incorrect
149 |         string as *const libc::c_void,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[c_void]`, found *-ptr
    |
    = note: expected reference `&[c_void]`
             found raw pointer `*const c_void`
note: function defined here
   --> src/lib/xmalloc.rs:135:26
    |
135 | pub unsafe extern "C" fn xmemdup<'h0,'h1>(
    |                          ^^^^^^^
136 |     mut p: &'h0 [(libc::c_void)],
    |     ----------------------------
137 |     mut s: size_t,
    |     -------------


error[E0606]: casting `&'h0 [i8]` as `*const c_void` is invalid
   --> src/lib/xmalloc.rs:149:9
    |
149 |         string as *const libc::c_void,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error[E0308]: mismatched types
   --> src/trees.rs:414:34
    |
414 |     let mut tree: *mut ct_data = (*desc).dyn_tree;
    |                   ------------   ^^^^^^^^^^^^^^^^ types differ in mutability
    |                   |
    |                   expected due to this
    |
    = note: expected raw pointer `*mut ct_data`
                 found reference `&[Cell<ct_data>]`


error[E0308]: mismatched types
   --> src/trees.rs:419:35
    |
419 |     let mut stree: *mut ct_data = (*desc).static_tree;
    |                    ------------   ^^^^^^^^^^^^^^^^^^^ types differ in mutability
    |                    |
    |                    expected due to this
    |
    = note: expected raw pointer `*mut ct_data`
                 found reference `&[ct_data]`


error[E0308]: mismatched types
   --> src/trees.rs:551:35
    |
551 |     let mut stree: *mut ct_data = (*desc).static_tree;
    |                    ------------   ^^^^^^^^^^^^^^^^^^^ types differ in mutability
    |                    |
    |                    expected due to this
    |
    = note: expected raw pointer `*mut ct_data`
                 found reference `&[ct_data]`


error[E0308]: mismatched types
   --> src/util.rs:563:62
    |
563 |     let mut p: &[core::cell::Cell<(libc::c_char)>] = strrchr(name, '.' as i32);
    |                                                      ------- ^^^^ expected `i8`, found slice `[i8]`
    |                                                      |
    |                                                      arguments to this function are incorrect
    |
    = note:    expected raw pointer `*const i8`
            found mutable reference `&'h0 mut [i8]`
note: function defined here
   --> src/util.rs:19:8
    |
19  |     fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    |        ^^^^^^^


error[E0599]: no method named `is_null` found for struct `Cell` in the current scope
   --> src/util.rs:564:16
    |
564 |     if &(p)[0].is_null() {
    |                ^^^^^^^ method not found in `Cell<i8>`


error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/util.rs:572:19
    |
572 |         p = &(p)[((-1) as usize) ..];
    |                   ^^^^
    |                   |
    |                   cannot apply unary operator `-`
    |                   help: you may have meant the maximum value of `usize`: `usize::MAX`
    |
    = note: unsigned values cannot be negated


error[E0277]: can't compare `Cell<i8>` with `i8`
   --> src/util.rs:576:22
    |
576 |         if !(&(p)[0] != &(&*(name))[0]) {
    |                      ^^ no implementation for `Cell<i8> == i8`
    |
    = help: the trait `PartialEq<i8>` is not implemented for `Cell<i8>`
    = help: the trait `PartialEq` is implemented for `Cell<T>`
    = note: required because of the requirements on the impl of `PartialEq<&i8>` for `&Cell<i8>`

error[E0605]: non-primitive cast: `Option<&Cell<i8>>` as `i32`
   --> src/util.rs:573:12
    |
573 |         if (p).get(0) as libc::c_int == '.' as i32 {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

